[0.029s] Invoking command in '/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/build/slam-tutorial': CMAKE_PREFIX_PATH=${CMAKE_PREFIX_PATH}:/opt/ros/foxy /usr/bin/cmake --build /home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/build/slam-tutorial -- -j12 -l12
[0.058s] -- Found ament_cmake: 0.9.11 (/opt/ros/foxy/share/ament_cmake/cmake)
[0.081s] -- Using PYTHON_EXECUTABLE: /usr/bin/python3
[0.308s] -- Override CMake install command with custom implementation using symlinks instead of copying resources
[0.318s] -- Found rclcpp: 2.4.2 (/opt/ros/foxy/share/rclcpp/cmake)
[0.494s] -- Using all available rosidl_typesupport_c: rosidl_typesupport_fastrtps_c;rosidl_typesupport_introspection_c
[0.498s] -- Found rosidl_adapter: 1.3.0 (/opt/ros/foxy/share/rosidl_adapter/cmake)
[4.602s] -- Using all available rosidl_typesupport_cpp: rosidl_typesupport_fastrtps_cpp;rosidl_typesupport_introspection_cpp
[4.667s] -- Found rmw_implementation_cmake: 1.0.4 (/opt/ros/foxy/share/rmw_implementation_cmake/cmake)
[4.668s] -- Using RMW implementation 'rmw_fastrtps_cpp' as default
[4.872s] -- Found sensor_msgs: 2.0.5 (/opt/ros/foxy/share/sensor_msgs/cmake)
[5.021s] -- Found image_transport: 2.4.0 (/opt/ros/foxy/share/image_transport/cmake)
[5.963s] -- Found tf2_ros: 0.13.14 (/opt/ros/foxy/share/tf2_ros/cmake)
[6.382s] -- Found nav_msgs: 2.0.5 (/opt/ros/foxy/share/nav_msgs/cmake)
[6.477s] -- Found ament_lint_auto: 0.9.8 (/opt/ros/foxy/share/ament_lint_auto/cmake)
[6.598s] -- Added test 'copyright' to check source files copyright and LICENSE
[6.640s] -- Added test 'cppcheck' to perform static code analysis on C / C++ code
[6.641s] -- Configured cppcheck include dirs: 
[6.641s] -- Configured cppcheck exclude dirs and/or files: 
[6.683s] -- Added test 'cpplint' to check C / C++ code against the Google style
[6.683s] -- Configured cpplint exclude dirs and/or files: 
[6.690s] -- Added test 'flake8' to check Python code syntax and style conventions
[6.700s] -- Added test 'lint_cmake' to check CMake code style
[6.706s] -- Added test 'pep257' to check Python code against some of the style conventions in PEP 257
[6.750s] -- Added test 'uncrustify' to check C / C++ code style
[6.750s] -- Configured uncrustify additional arguments: 
[6.756s] -- Added test 'xmllint' to check XML markup files
[6.764s] -- Configuring done
[6.835s] -- Generating done
[6.839s] -- Build files have been written to: /home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/build/slam-tutorial
[6.891s] [ 33%] Built target stereo_calibration
[6.904s] [35m[1mScanning dependencies of target main_lidar_node[0m
[6.911s] [35m[1mScanning dependencies of target main_node[0m
[6.962s] [ 50%] [32mBuilding CXX object CMakeFiles/main_node.dir/executables/main.cpp.o[0m
[7.001s] [ 66%] [32mBuilding CXX object CMakeFiles/main_lidar_node.dir/executables/main_lidar.cpp.o[0m
[11.629s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In member function â€˜[01m[Kstd::vector<Eigen::Matrix<double, 3, 1> > SLAM_Context::get_registered_map() const[m[Kâ€™:
[11.629s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:83:26:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[11.630s]    83 |         for (const auto &[01;35m[K[[m[Kvoxel, voxel_block] : map_) {
[11.630s]       |                          [01;35m[K^[m[K
[11.674s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In function â€˜[01m[Kstd::tuple<std::vector<Eigen::Matrix<double, 3, 1, 0, 3, 1>, std::allocator<Eigen::Matrix<double, 3, 1, 0, 3, 1> > >, std::vector<Eigen::Matrix<double, 3, 1, 0, 3, 1>, std::allocator<Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > get_correspondence(const std::vector<Eigen::Matrix<double, 3, 1> >&, const tsl::robin_map<Eigen::Matrix<int, 3, 1>, VoxelBlock, VoxelHash>&, double)[m[Kâ€™:
[11.675s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:179:16:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[11.675s]   179 |     const auto [01;35m[K[[m[Ksource, target] = tbb::parallel_reduce(
[11.675s]       |                [01;35m[K^[m[K
[11.675s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In lambda function:
[11.675s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:187:19:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[11.675s]   187 |             auto &[01;35m[K[[m[Ksrc, tgt] = res;
[11.675s]       |                   [01;35m[K^[m[K
[11.681s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In member function â€˜[01m[Kstd::vector<Eigen::Matrix<double, 3, 1> > SLAM_Context::get_registered_map() const[m[Kâ€™:
[11.681s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:77:26:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[11.681s]    77 |         for (const auto &[01;35m[K[[m[Kvoxel, voxel_block] : map_) {
[11.681s]       |                          [01;35m[K^[m[K
[11.692s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In lambda function:
[11.693s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:201:19:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[11.693s]   201 |             auto &[01;35m[K[[m[Ksrc, tgt] = a;
[11.693s]       |                   [01;35m[K^[m[K
[11.693s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:202:25:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[11.693s]   202 |             const auto &[01;35m[K[[m[Ksrcp, tgtp] = b;
[11.693s]       |                         [01;35m[K^[m[K
[11.754s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In function â€˜[01m[Kstd::tuple<std::vector<Eigen::Matrix<double, 3, 1, 0, 3, 1>, std::allocator<Eigen::Matrix<double, 3, 1, 0, 3, 1> > >, std::vector<Eigen::Matrix<double, 3, 1, 0, 3, 1>, std::allocator<Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > get_correspondence(const std::vector<Eigen::Matrix<double, 3, 1> >&, const tsl::robin_map<Eigen::Matrix<int, 3, 1>, VoxelBlock, VoxelHash>&, double)[m[Kâ€™:
[11.754s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:173:16:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[11.754s]   173 |     const auto [01;35m[K[[m[Ksource, target] = tbb::parallel_reduce(
[11.754s]       |                [01;35m[K^[m[K
[11.755s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In lambda function:
[11.755s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:181:19:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[11.755s]   181 |             auto &[01;35m[K[[m[Ksrc, tgt] = res;
[11.755s]       |                   [01;35m[K^[m[K
[11.768s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In lambda function:
[11.768s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:195:19:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[11.768s]   195 |             auto &[01;35m[K[[m[Ksrc, tgt] = a;
[11.768s]       |                   [01;35m[K^[m[K
[11.768s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:196:25:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[11.769s]   196 |             const auto &[01;35m[K[[m[Ksrcp, tgtp] = b;
[11.769s]       |                         [01;35m[K^[m[K
[11.786s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In function â€˜[01m[KSophus::SE3d AlignClouds(const std::vector<Eigen::Matrix<double, 3, 1> >&, const std::vector<Eigen::Matrix<double, 3, 1> >&, double)[m[Kâ€™:
[11.787s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:233:17:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[11.787s]   233 |     const auto &[01;35m[K[[m[KJTJ, JTr] = tbb::parallel_reduce(
[11.787s]       |                 [01;35m[K^[m[K
[11.787s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In lambda function:
[11.787s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:241:19:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[11.787s]   241 |             auto &[01;35m[K[[m[KJTJ_private, JTr_private] = J;
[11.787s]       |                   [01;35m[K^[m[K
[11.787s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:243:29:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[11.788s]   243 |                 const auto &[01;35m[K[[m[KJ_r, residual] = compute_jacobian_and_residual(i);
[11.788s]       |                             [01;35m[K^[m[K
[11.846s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In function â€˜[01m[KSophus::SE3d AlignClouds(const std::vector<Eigen::Matrix<double, 3, 1> >&, const std::vector<Eigen::Matrix<double, 3, 1> >&, double)[m[Kâ€™:
[11.846s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:227:17:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[11.846s]   227 |     const auto &[01;35m[K[[m[KJTJ, JTr] = tbb::parallel_reduce(
[11.846s]       |                 [01;35m[K^[m[K
[11.846s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In lambda function:
[11.846s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:235:19:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[11.846s]   235 |             auto &[01;35m[K[[m[KJTJ_private, JTr_private] = J;
[11.847s]       |                   [01;35m[K^[m[K
[11.847s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:237:29:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[11.847s]   237 |                 const auto &[01;35m[K[[m[KJ_r, residual] = compute_jacobian_and_residual(i);
[11.847s]       |                             [01;35m[K^[m[K
[11.968s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In function â€˜[01m[KSophus::SE3d register_frame_icp(const std::vector<Eigen::Matrix<double, 3, 1> >&, const tsl::robin_map<Eigen::Matrix<int, 3, 1>, VoxelBlock, VoxelHash>&, const SE3d&, double, double)[m[Kâ€™:
[11.968s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:272:21:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[11.968s]   272 |         const auto &[01;35m[K[[m[Ksrc, tgt] = get_correspondence(source, map, max_correspondence_distance);
[11.968s]       |                     [01;35m[K^[m[K
[12.025s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In function â€˜[01m[Kstd::vector<Eigen::Matrix<double, 3, 1> > voxelize_downsample(const std::vector<Eigen::Matrix<double, 3, 1> >&, double)[m[Kâ€™:
[12.025s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:321:22:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[12.025s]   321 |     for (const auto &[01;35m[K[[m[Kvoxel, point] : grid) {
[12.025s]       |                      [01;35m[K^[m[K
[12.033s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In function â€˜[01m[Kvoid RemovePointsFarFromLocation(const Vector3d&)[m[Kâ€™:
[12.034s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:354:22:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[12.034s]   354 |     for (const auto &[01;35m[K[[m[Kvoxel, voxel_block] : slam_ctx.map_) {
[12.034s]       |                      [01;35m[K^[m[K
[12.034s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In function â€˜[01m[KSophus::SE3d register_frame_icp(const std::vector<Eigen::Matrix<double, 3, 1> >&, const tsl::robin_map<Eigen::Matrix<int, 3, 1>, VoxelBlock, VoxelHash>&, const SE3d&, double, double)[m[Kâ€™:
[12.034s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:266:21:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[12.035s]   266 |         const auto &[01;35m[K[[m[Ksrc, tgt] = get_correspondence(source, map, max_correspondence_distance);
[12.035s]       |                     [01;35m[K^[m[K
[12.035s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In function â€˜[01m[Kvoid update_map(std::vector<Eigen::Matrix<double, 3, 1> >, const SE3d&)[m[Kâ€™:
[12.035s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:367:28:[m[K [01;35m[Kwarning: [m[Kunused variable â€˜[01m[Korigin[m[Kâ€™ [[01;35m[K-Wunused-variable[m[K]
[12.035s]   367 |     const Eigen::Vector3d &[01;35m[Korigin[m[K = pose.translation();
[12.035s]       |                            [01;35m[K^~~~~~[m[K
[12.092s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In function â€˜[01m[Kstd::vector<Eigen::Matrix<double, 3, 1> > voxelize_downsample(const std::vector<Eigen::Matrix<double, 3, 1> >&, double)[m[Kâ€™:
[12.092s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:315:22:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[12.092s]   315 |     for (const auto &[01;35m[K[[m[Kvoxel, point] : grid) {
[12.092s]       |                      [01;35m[K^[m[K
[12.100s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In function â€˜[01m[Kvoid RemovePointsFarFromLocation(const Vector3d&)[m[Kâ€™:
[12.100s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:348:22:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[12.100s]   348 |     for (const auto &[01;35m[K[[m[Kvoxel, voxel_block] : slam_ctx.map_) {
[12.100s]       |                      [01;35m[K^[m[K
[12.101s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In function â€˜[01m[Kvoid update_map(std::vector<Eigen::Matrix<double, 3, 1> >, const SE3d&)[m[Kâ€™:
[12.101s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:361:28:[m[K [01;35m[Kwarning: [m[Kunused variable â€˜[01m[Korigin[m[Kâ€™ [[01;35m[K-Wunused-variable[m[K]
[12.101s]   361 |     const Eigen::Vector3d &[01;35m[Korigin[m[K = pose.translation();
[12.101s]       |                            [01;35m[K^~~~~~[m[K
[12.152s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K At global scope:
[12.153s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:455:62:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[KPointCloud2[m[Kâ€™ does not name a type
[12.153s]   455 | inline std::vector<Eigen::Vector3d> PointCloud2ToEigen(const [01;31m[KPointCloud2[m[K::ConstSharedPtr msg) {
[12.153s]       |                                                              [01;31m[K^~~~~~~~~~~[m[K
[12.153s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:455:90:[m[K [01;31m[Kerror: [m[Kexpected unqualified-id before â€˜[01m[Kmsg[m[Kâ€™
[12.153s]   455 | inline std::vector<Eigen::Vector3d> PointCloud2ToEigen(const PointCloud2::ConstSharedPtr [01;31m[Kmsg[m[K) {
[12.154s]       |                                                                                          [01;31m[K^~~[m[K
[12.154s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:455:89:[m[K [01;31m[Kerror: [m[Kexpected â€˜[01m[K)[m[Kâ€™ before â€˜[01m[Kmsg[m[Kâ€™
[12.154s]   455 | inline std::vector<Eigen::Vector3d> PointCloud2ToEigen[34m[K([m[Kconst PointCloud2::ConstSharedPtr[01;31m[K [m[K[32m[Kmsg[m[K) {
[12.154s]       |                                                       [34m[K~[m[K                                 [01;31m[K^[m[K[32m[K~~~[m[K
[12.155s]       |                                                                                         [32m[K)[m[K
[12.155s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:455:90:[m[K [01;31m[Kerror: [m[Kexpected initializer before â€˜[01m[Kmsg[m[Kâ€™
[12.155s]   455 | inline std::vector<Eigen::Vector3d> PointCloud2ToEigen(const PointCloud2::ConstSharedPtr [01;31m[Kmsg[m[K) {
[12.156s]       |                                                                                          [01;31m[K^~~[m[K
[12.212s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In constructor â€˜[01m[KLidarSubscriberNode::LidarSubscriberNode()[m[Kâ€™:
[12.213s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:476:25:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[KImageSubscriberNode[m[Kâ€™ has not been declared
[12.213s]   476 |              std::bind(&[01;31m[KImageSubscriberNode[m[K::lidar_callback, this, std::placeholders::_1));
[12.213s]       |                         [01;31m[K^~~~~~~~~~~~~~~~~~~[m[K
[12.224s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:478:119:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Ksubscription_left_image[m[Kâ€™ was not declared in this scope
[12.224s]   478 |         sync_ = std::make_shared<message_filters::TimeSynchronizer<sensor_msgs::msg::Image, sensor_msgs::msg::Image>>([01;31m[Ksubscription_left_image[m[K, subscription_right_image, 3);
[12.224s]       |                                                                                                                       [01;31m[K^~~~~~~~~~~~~~~~~~~~~~~[m[K
[12.235s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:478:144:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Ksubscription_right_image[m[Kâ€™ was not declared in this scope
[12.235s]   478 | e_shared<message_filters::TimeSynchronizer<sensor_msgs::msg::Image, sensor_msgs::msg::Image>>(subscription_left_image, [01;31m[Ksubscription_right_image[m[K, 3);
[12.235s]       |                                                                                                                        [01;31m[K^~~~~~~~~~~~~~~~~~~~~~~~[m[K
[12.235s] 
[12.257s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:479:44:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[KImageSubscriberNode[m[Kâ€™ has not been declared
[12.257s]   479 |         sync_->registerCallback(std::bind(&[01;31m[KImageSubscriberNode[m[K::stereo_image_callback, this, std::placeholders::_1, std::placeholders::_2));
[12.257s]       |                                            [01;31m[K^~~~~~~~~~~~~~~~~~~[m[K
[12.274s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In member function â€˜[01m[Kvoid LidarSubscriberNode::lidar_callback(const ConstSharedPtr&)[m[Kâ€™:
[12.274s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:496:29:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[KPointCloud2ToEigen[m[Kâ€™ was not declared in this scope
[12.274s]   496 |         const auto points = [01;31m[KPointCloud2ToEigen[m[K(msg);
[12.274s]       |                             [01;31m[K^~~~~~~~~~~~~~~~~~[m[K
[12.274s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:497:14:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[12.275s]   497 |         auto [01;35m[K[[m[Kcloud_map, cloud_keypoints, new_pose] = register_frame(points);
[12.275s]       |              [01;35m[K^[m[K
[12.282s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:512:38:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kimg_msg_left[m[Kâ€™ was not declared in this scope
[12.282s]   512 |         transform_msg.header.stamp = [01;31m[Kimg_msg_left[m[K->header.stamp;
[12.282s]       |                                      [01;31m[K^~~~~~~~~~~~[m[K
[12.302s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In member function â€˜[01m[Kvoid ImageSubscriberNode::stereo_image_callback(const ConstSharedPtr&, const ConstSharedPtr&)[m[Kâ€™:
[12.303s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:606:14:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
[12.303s]   606 |         auto [01;35m[K[[m[Kcloud_map, cloud_keypoints, new_pose] = register_frame(triangulated_points);
[12.303s]       |              [01;35m[K^[m[K
[12.310s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In function â€˜[01m[Kint main(int, char**)[m[Kâ€™:
[12.310s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:592:34:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[KImageSubscriberNode[m[Kâ€™ was not declared in this scope; did you mean â€˜[01m[KLidarSubscriberNode[m[Kâ€™?
[12.310s]   592 |     auto node = std::make_shared<[01;31m[KImageSubscriberNode[m[K>();
[12.310s]       |                                  [01;31m[K^~~~~~~~~~~~~~~~~~~[m[K
[12.311s]       |                                  [32m[KLidarSubscriberNode[m[K
[12.311s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:592:55:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[Kmake_shared<<expression error> >()[m[Kâ€™
[12.311s]   592 |     auto node = std::make_shared<ImageSubscriberNode>([01;31m[K)[m[K;
[12.311s]       |                                                       [01;31m[K^[m[K
[12.311s] In file included from [01m[K/usr/include/c++/9/memory:81[m[K,
[12.311s]                  from [01m[K/usr/local/include/fmt/format.h:41[m[K,
[12.311s]                  from [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:2[m[K:
[12.311s] [01m[K/usr/include/c++/9/bits/shared_ptr.h:714:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp, class ... _Args> std::shared_ptr<_Tp> std::make_shared(_Args&& ...)[m[Kâ€™
[12.311s]   714 |     [01;36m[Kmake_shared[m[K(_Args&&... __args)
[12.311s]       |     [01;36m[K^~~~~~~~~~~[m[K
[12.311s] [01m[K/usr/include/c++/9/bits/shared_ptr.h:714:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[12.312s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:592:55:[m[K [01;31m[Kerror: [m[Ktemplate argument 1 is invalid
[12.312s]   592 |     auto node = std::make_shared<ImageSubscriberNode>([01;31m[K)[m[K;
[12.312s]       |                                                       [01;31m[K^[m[K
[12.359s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:570:25:[m[K [01;35m[Kwarning: [m[Kvariable â€˜[01m[Kp1[m[Kâ€™ set but not used [[01;35m[K-Wunused-but-set-variable[m[K]
[12.359s]   570 |         Eigen::Vector3d [01;35m[Kp1[m[K = matched_left_eigen.row(0);
[12.359s]       |                         [01;35m[K^~[m[K
[12.360s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:571:25:[m[K [01;35m[Kwarning: [m[Kvariable â€˜[01m[Kp2[m[Kâ€™ set but not used [[01;35m[K-Wunused-but-set-variable[m[K]
[12.360s]   571 |         Eigen::Vector3d [01;35m[Kp2[m[K = matched_right_eigen.row(0);
[12.360s]       |                         [01;35m[K^~[m[K
[12.360s] [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:573:25:[m[K [01;35m[Kwarning: [m[Kvariable â€˜[01m[Ke1[m[Kâ€™ set but not used [[01;35m[K-Wunused-but-set-variable[m[K]
[12.360s]   573 |         Eigen::Vector3d [01;35m[Ke1[m[K = compute_epipole(F);
[12.360s]       |                         [01;35m[K^~[m[K
[21.452s] make[2]: *** [CMakeFiles/main_lidar_node.dir/build.make:63: CMakeFiles/main_lidar_node.dir/executables/main_lidar.cpp.o] Error 1
[21.452s] make[1]: *** [CMakeFiles/Makefile2:118: CMakeFiles/main_lidar_node.dir/all] Error 2
[21.452s] make[1]: *** Waiting for unfinished jobs....
[40.007s] [ 83%] [32m[1mLinking CXX executable main_node[0m
[43.382s] [ 83%] Built target main_node
[43.383s] make: *** [Makefile:141: all] Error 2
[43.388s] Invoked command in '/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/build/slam-tutorial' returned '2': CMAKE_PREFIX_PATH=${CMAKE_PREFIX_PATH}:/opt/ros/foxy /usr/bin/cmake --build /home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/build/slam-tutorial -- -j12 -l12
