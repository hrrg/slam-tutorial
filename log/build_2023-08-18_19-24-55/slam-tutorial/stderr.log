[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In member function â€˜[01m[Kstd::vector<Eigen::Matrix<double, 3, 1> > SLAM_Context::get_registered_map() const[m[Kâ€™:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:83:26:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
   83 |         for (const auto &[01;35m[K[[m[Kvoxel, voxel_block] : map_) {
      |                          [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In function â€˜[01m[Kstd::tuple<std::vector<Eigen::Matrix<double, 3, 1, 0, 3, 1>, std::allocator<Eigen::Matrix<double, 3, 1, 0, 3, 1> > >, std::vector<Eigen::Matrix<double, 3, 1, 0, 3, 1>, std::allocator<Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > get_correspondence(const std::vector<Eigen::Matrix<double, 3, 1> >&, const tsl::robin_map<Eigen::Matrix<int, 3, 1>, VoxelBlock, VoxelHash>&, double)[m[Kâ€™:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:179:16:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  179 |     const auto [01;35m[K[[m[Ksource, target] = tbb::parallel_reduce(
      |                [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In lambda function:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:187:19:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  187 |             auto &[01;35m[K[[m[Ksrc, tgt] = res;
      |                   [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In member function â€˜[01m[Kstd::vector<Eigen::Matrix<double, 3, 1> > SLAM_Context::get_registered_map() const[m[Kâ€™:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:77:26:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
   77 |         for (const auto &[01;35m[K[[m[Kvoxel, voxel_block] : map_) {
      |                          [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In lambda function:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:201:19:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  201 |             auto &[01;35m[K[[m[Ksrc, tgt] = a;
      |                   [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:202:25:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  202 |             const auto &[01;35m[K[[m[Ksrcp, tgtp] = b;
      |                         [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In function â€˜[01m[Kstd::tuple<std::vector<Eigen::Matrix<double, 3, 1, 0, 3, 1>, std::allocator<Eigen::Matrix<double, 3, 1, 0, 3, 1> > >, std::vector<Eigen::Matrix<double, 3, 1, 0, 3, 1>, std::allocator<Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > get_correspondence(const std::vector<Eigen::Matrix<double, 3, 1> >&, const tsl::robin_map<Eigen::Matrix<int, 3, 1>, VoxelBlock, VoxelHash>&, double)[m[Kâ€™:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:173:16:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  173 |     const auto [01;35m[K[[m[Ksource, target] = tbb::parallel_reduce(
      |                [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In lambda function:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:181:19:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  181 |             auto &[01;35m[K[[m[Ksrc, tgt] = res;
      |                   [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In lambda function:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:195:19:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  195 |             auto &[01;35m[K[[m[Ksrc, tgt] = a;
      |                   [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:196:25:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  196 |             const auto &[01;35m[K[[m[Ksrcp, tgtp] = b;
      |                         [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In function â€˜[01m[KSophus::SE3d AlignClouds(const std::vector<Eigen::Matrix<double, 3, 1> >&, const std::vector<Eigen::Matrix<double, 3, 1> >&, double)[m[Kâ€™:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:233:17:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  233 |     const auto &[01;35m[K[[m[KJTJ, JTr] = tbb::parallel_reduce(
      |                 [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In lambda function:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:241:19:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  241 |             auto &[01;35m[K[[m[KJTJ_private, JTr_private] = J;
      |                   [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:243:29:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  243 |                 const auto &[01;35m[K[[m[KJ_r, residual] = compute_jacobian_and_residual(i);
      |                             [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In function â€˜[01m[KSophus::SE3d AlignClouds(const std::vector<Eigen::Matrix<double, 3, 1> >&, const std::vector<Eigen::Matrix<double, 3, 1> >&, double)[m[Kâ€™:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:227:17:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  227 |     const auto &[01;35m[K[[m[KJTJ, JTr] = tbb::parallel_reduce(
      |                 [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In lambda function:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:235:19:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  235 |             auto &[01;35m[K[[m[KJTJ_private, JTr_private] = J;
      |                   [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:237:29:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  237 |                 const auto &[01;35m[K[[m[KJ_r, residual] = compute_jacobian_and_residual(i);
      |                             [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In function â€˜[01m[KSophus::SE3d register_frame_icp(const std::vector<Eigen::Matrix<double, 3, 1> >&, const tsl::robin_map<Eigen::Matrix<int, 3, 1>, VoxelBlock, VoxelHash>&, const SE3d&, double, double)[m[Kâ€™:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:272:21:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  272 |         const auto &[01;35m[K[[m[Ksrc, tgt] = get_correspondence(source, map, max_correspondence_distance);
      |                     [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In function â€˜[01m[Kstd::vector<Eigen::Matrix<double, 3, 1> > voxelize_downsample(const std::vector<Eigen::Matrix<double, 3, 1> >&, double)[m[Kâ€™:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:321:22:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  321 |     for (const auto &[01;35m[K[[m[Kvoxel, point] : grid) {
      |                      [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In function â€˜[01m[Kvoid RemovePointsFarFromLocation(const Vector3d&)[m[Kâ€™:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:354:22:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  354 |     for (const auto &[01;35m[K[[m[Kvoxel, voxel_block] : slam_ctx.map_) {
      |                      [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In function â€˜[01m[KSophus::SE3d register_frame_icp(const std::vector<Eigen::Matrix<double, 3, 1> >&, const tsl::robin_map<Eigen::Matrix<int, 3, 1>, VoxelBlock, VoxelHash>&, const SE3d&, double, double)[m[Kâ€™:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:266:21:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  266 |         const auto &[01;35m[K[[m[Ksrc, tgt] = get_correspondence(source, map, max_correspondence_distance);
      |                     [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In function â€˜[01m[Kvoid update_map(std::vector<Eigen::Matrix<double, 3, 1> >, const SE3d&)[m[Kâ€™:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:367:28:[m[K [01;35m[Kwarning: [m[Kunused variable â€˜[01m[Korigin[m[Kâ€™ [[01;35m[K-Wunused-variable[m[K]
  367 |     const Eigen::Vector3d &[01;35m[Korigin[m[K = pose.translation();
      |                            [01;35m[K^~~~~~[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In function â€˜[01m[Kstd::vector<Eigen::Matrix<double, 3, 1> > voxelize_downsample(const std::vector<Eigen::Matrix<double, 3, 1> >&, double)[m[Kâ€™:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:315:22:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  315 |     for (const auto &[01;35m[K[[m[Kvoxel, point] : grid) {
      |                      [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In function â€˜[01m[Kvoid RemovePointsFarFromLocation(const Vector3d&)[m[Kâ€™:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:348:22:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  348 |     for (const auto &[01;35m[K[[m[Kvoxel, voxel_block] : slam_ctx.map_) {
      |                      [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In function â€˜[01m[Kvoid update_map(std::vector<Eigen::Matrix<double, 3, 1> >, const SE3d&)[m[Kâ€™:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:361:28:[m[K [01;35m[Kwarning: [m[Kunused variable â€˜[01m[Korigin[m[Kâ€™ [[01;35m[K-Wunused-variable[m[K]
  361 |     const Eigen::Vector3d &[01;35m[Korigin[m[K = pose.translation();
      |                            [01;35m[K^~~~~~[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K At global scope:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:455:62:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[KPointCloud2[m[Kâ€™ does not name a type
  455 | inline std::vector<Eigen::Vector3d> PointCloud2ToEigen(const [01;31m[KPointCloud2[m[K::ConstSharedPtr msg) {
      |                                                              [01;31m[K^~~~~~~~~~~[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:455:90:[m[K [01;31m[Kerror: [m[Kexpected unqualified-id before â€˜[01m[Kmsg[m[Kâ€™
  455 | inline std::vector<Eigen::Vector3d> PointCloud2ToEigen(const PointCloud2::ConstSharedPtr [01;31m[Kmsg[m[K) {
      |                                                                                          [01;31m[K^~~[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:455:89:[m[K [01;31m[Kerror: [m[Kexpected â€˜[01m[K)[m[Kâ€™ before â€˜[01m[Kmsg[m[Kâ€™
  455 | inline std::vector<Eigen::Vector3d> PointCloud2ToEigen[34m[K([m[Kconst PointCloud2::ConstSharedPtr[01;31m[K [m[K[32m[Kmsg[m[K) {
      |                                                       [34m[K~[m[K                                 [01;31m[K^[m[K[32m[K~~~[m[K
      |                                                                                         [32m[K)[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:455:90:[m[K [01;31m[Kerror: [m[Kexpected initializer before â€˜[01m[Kmsg[m[Kâ€™
  455 | inline std::vector<Eigen::Vector3d> PointCloud2ToEigen(const PointCloud2::ConstSharedPtr [01;31m[Kmsg[m[K) {
      |                                                                                          [01;31m[K^~~[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In constructor â€˜[01m[KLidarSubscriberNode::LidarSubscriberNode()[m[Kâ€™:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:476:25:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[KImageSubscriberNode[m[Kâ€™ has not been declared
  476 |              std::bind(&[01;31m[KImageSubscriberNode[m[K::lidar_callback, this, std::placeholders::_1));
      |                         [01;31m[K^~~~~~~~~~~~~~~~~~~[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:478:119:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Ksubscription_left_image[m[Kâ€™ was not declared in this scope
  478 |         sync_ = std::make_shared<message_filters::TimeSynchronizer<sensor_msgs::msg::Image, sensor_msgs::msg::Image>>([01;31m[Ksubscription_left_image[m[K, subscription_right_image, 3);
      |                                                                                                                       [01;31m[K^~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:478:144:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Ksubscription_right_image[m[Kâ€™ was not declared in this scope
  478 | e_shared<message_filters::TimeSynchronizer<sensor_msgs::msg::Image, sensor_msgs::msg::Image>>(subscription_left_image, [01;31m[Ksubscription_right_image[m[K, 3);
      |                                                                                                                        [01;31m[K^~~~~~~~~~~~~~~~~~~~~~~~[m[K

[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:479:44:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[KImageSubscriberNode[m[Kâ€™ has not been declared
  479 |         sync_->registerCallback(std::bind(&[01;31m[KImageSubscriberNode[m[K::stereo_image_callback, this, std::placeholders::_1, std::placeholders::_2));
      |                                            [01;31m[K^~~~~~~~~~~~~~~~~~~[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In member function â€˜[01m[Kvoid LidarSubscriberNode::lidar_callback(const ConstSharedPtr&)[m[Kâ€™:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:496:29:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[KPointCloud2ToEigen[m[Kâ€™ was not declared in this scope
  496 |         const auto points = [01;31m[KPointCloud2ToEigen[m[K(msg);
      |                             [01;31m[K^~~~~~~~~~~~~~~~~~[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:497:14:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  497 |         auto [01;35m[K[[m[Kcloud_map, cloud_keypoints, new_pose] = register_frame(points);
      |              [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:512:38:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kimg_msg_left[m[Kâ€™ was not declared in this scope
  512 |         transform_msg.header.stamp = [01;31m[Kimg_msg_left[m[K->header.stamp;
      |                                      [01;31m[K^~~~~~~~~~~~[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:[m[K In member function â€˜[01m[Kvoid ImageSubscriberNode::stereo_image_callback(const ConstSharedPtr&, const ConstSharedPtr&)[m[Kâ€™:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:606:14:[m[K [01;35m[Kwarning: [m[Kstructured bindings only available with â€˜[01m[K-std=c++17[m[Kâ€™ or â€˜[01m[K-std=gnu++17[m[Kâ€™
  606 |         auto [01;35m[K[[m[Kcloud_map, cloud_keypoints, new_pose] = register_frame(triangulated_points);
      |              [01;35m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:[m[K In function â€˜[01m[Kint main(int, char**)[m[Kâ€™:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:592:34:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[KImageSubscriberNode[m[Kâ€™ was not declared in this scope; did you mean â€˜[01m[KLidarSubscriberNode[m[Kâ€™?
  592 |     auto node = std::make_shared<[01;31m[KImageSubscriberNode[m[K>();
      |                                  [01;31m[K^~~~~~~~~~~~~~~~~~~[m[K
      |                                  [32m[KLidarSubscriberNode[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:592:55:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[Kmake_shared<<expression error> >()[m[Kâ€™
  592 |     auto node = std::make_shared<ImageSubscriberNode>([01;31m[K)[m[K;
      |                                                       [01;31m[K^[m[K
In file included from [01m[K/usr/include/c++/9/memory:81[m[K,
                 from [01m[K/usr/local/include/fmt/format.h:41[m[K,
                 from [01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:2[m[K:
[01m[K/usr/include/c++/9/bits/shared_ptr.h:714:5:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Ktemplate<class _Tp, class ... _Args> std::shared_ptr<_Tp> std::make_shared(_Args&& ...)[m[Kâ€™
  714 |     [01;36m[Kmake_shared[m[K(_Args&&... __args)
      |     [01;36m[K^~~~~~~~~~~[m[K
[01m[K/usr/include/c++/9/bits/shared_ptr.h:714:5:[m[K [01;36m[Knote: [m[K  template argument deduction/substitution failed:
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main_lidar.cpp:592:55:[m[K [01;31m[Kerror: [m[Ktemplate argument 1 is invalid
  592 |     auto node = std::make_shared<ImageSubscriberNode>([01;31m[K)[m[K;
      |                                                       [01;31m[K^[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:570:25:[m[K [01;35m[Kwarning: [m[Kvariable â€˜[01m[Kp1[m[Kâ€™ set but not used [[01;35m[K-Wunused-but-set-variable[m[K]
  570 |         Eigen::Vector3d [01;35m[Kp1[m[K = matched_left_eigen.row(0);
      |                         [01;35m[K^~[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:571:25:[m[K [01;35m[Kwarning: [m[Kvariable â€˜[01m[Kp2[m[Kâ€™ set but not used [[01;35m[K-Wunused-but-set-variable[m[K]
  571 |         Eigen::Vector3d [01;35m[Kp2[m[K = matched_right_eigen.row(0);
      |                         [01;35m[K^~[m[K
[01m[K/home/jeongmyung/slam-tutorial_ws/src/slam-tutorial/executables/main.cpp:573:25:[m[K [01;35m[Kwarning: [m[Kvariable â€˜[01m[Ke1[m[Kâ€™ set but not used [[01;35m[K-Wunused-but-set-variable[m[K]
  573 |         Eigen::Vector3d [01;35m[Ke1[m[K = compute_epipole(F);
      |                         [01;35m[K^~[m[K
make[2]: *** [CMakeFiles/main_lidar_node.dir/build.make:63: CMakeFiles/main_lidar_node.dir/executables/main_lidar.cpp.o] Error 1
make[1]: *** [CMakeFiles/Makefile2:118: CMakeFiles/main_lidar_node.dir/all] Error 2
make[1]: *** Waiting for unfinished jobs....
make: *** [Makefile:141: all] Error 2
